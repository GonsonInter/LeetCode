package 剑指.Normal;

public class 丑数_49 {

//    /**
//     * 只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）
//     * 首先除2，直到不能整除为止，然后除5到不能整除为止，然后除3直到不能整除为止。最终判断剩余的数字是否为1，如果是1则为丑数，否则不是丑数
//     *
//     * 暴力破解，会超时
//     */
//    public static int nthUglyNumber(int n) {
//        if (n <= 6) {return n;}
//
//        int count = 6, i = 7;
//
//        while (true) {
//            if (isUgly(i)) {++ count;}
//            if (count == n) {break;}
//            ++ i;
//        }
//
//        return i;
//    }
//
//    public static boolean isUgly(int num) {
//        if (num > 0 && num <= 6) {return true;}
//        else if (num <= 0) {return false;}
//
//        while (num % 5 == 0) {num /= 5;}
//        while (num % 3 == 0) {num /= 3;}
//        while (num % 2 == 0) {num /= 2;}
//
//        return num == 1;
//    }


//    /**
//     * 动态规划
//     * 依次计算丑数，后一个丑数可能是前面某个丑数乘以2或3或5的结果
//     *
//     * 设置3个索引a, b, c，分别记录前几个数已经被乘2， 乘3， 乘5了，比如a表示前(a-1)个数都已经乘过一次2了，下次应该乘2的是第a个数；
//     * b表示前(b-1)个数都已经乘过一次3了，下次应该乘3的是第b个数；c表示前(c-1)个数都已经乘过一次5了，下次应该乘5的是第c个数；
//     *
//     * 对于某个状态下的丑数序列，我们知道此时第a个数还没有乘2(有没有乘3或者乘5不知道）， 第b个数还没有乘3(有没有乘2或者乘5不知道），
//     * 第c个数还没有乘5(有没有乘2或者乘3不知道), 下一个丑数一定是从第a丑数乘2， 第b个数乘3， 第c个数乘5中获得，他们三者最小的那个就是下个丑数。
//     *
//     * 如果第a个数乘2后等于第b个数乘3，或者等于第c个数乘5， 说明这个新的丑数是有两种或者三种方式可以得到，这时应该给得到这个新丑数的组合对应的
//     * 索引都加一
//     */
//    public static int nthUglyNumber(int n) {
//        int[] dp = new int[n];  // 使用dp数组来存储丑数序列
//        dp[0] = 1;  // dp[0]已知为1
//        int a = 0, b = 0, c = 0;    // 下个应该通过乘2来获得新丑数的数据是第a个， 同理b, c
//
//        for(int i = 1; i < n; i++){
//            // 第a丑数个数需要通过乘2来得到下个丑数，第b丑数个数需要通过乘2来得到下个丑数，同理第c个数
//            int n2 = dp[a] * 2, n3 = dp[b] * 3, n5 = dp[c] * 5;
//            dp[i] = Math.min(Math.min(n2, n3), n5);
//            if(dp[i] == n2){
//                a++; // 第a个数已经通过乘2得到了一个新的丑数，那下个需要通过乘2得到一个新的丑数的数应该是第(a+1)个数
//            }
//            if(dp[i] == n3){
//                b++; // 第 b个数已经通过乘3得到了一个新的丑数，那下个需要通过乘3得到一个新的丑数的数应该是第(b+1)个数
//            }
//            if(dp[i] == n5){
//                c++; // 第 c个数已经通过乘5得到了一个新的丑数，那下个需要通过乘5得到一个新的丑数的数应该是第(c+1)个数
//            }
//        }
//        return dp[n-1];
//    }


    /**
     * 合并三个数组，每个数组分别
     */



    public static void main(String[] args) {
        // System.out.println(nthUglyNumber(10));
    }
}
